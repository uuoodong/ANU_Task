		C++의 다음 형 변환에 대한 조사.
					20181111 박종국
					20181133 최혜령
					20141589 우동헌
					20161178 이창준

1. C++의 다음 형 변환에 대해서 조사를 하시오. 
1) dynamic_cast <new_type> (expression) -상속 관계 안에서 포인터나 참조자의 
타입을 기본 클래스 → 파생 클래스로의 다운캐스팅과 다중 상속에서
 기본 클래스 간의 안전한 타입 캐스팅에 사용된다. 

-안전한 타입 캐스팅 : 런타임에 타입 검사를 하겠다는 의미 -const_cast 와 같이 
용도가 명확하기 때문에 다른 용도로는 사용하지 못한다. 
-상속 관계 안에서만 사용할 수 있다. -하나 이상의 가상 함수를 가져야 한다. 
-컴파일러의 RTTI (Runtime Type Information) 설정이 켜져있어야 한다.
 

2) reinterpret_cast <new_type> (expression) -임의의 포인터 타입끼리 변환을 허용하는 캐스트 연산자, 정수형을 포인터로 바꿀 수 있음 
-연관성이 없는 포인터 타입을 변환하기 위해서 사용 -강제 캐스팅을 수행 
3) static_cast <new_type> (expression) -논리적으로 변환 가능한 타입을 변환한다 -실수와 정수, 열거형과 정수형, 실수와 실수 사이의 변환 등을 허용한다 -compile 타임에 형변환에 대한 타입 오류를 잡아줌 -상속 관계에 있는 포인터 끼리 변환이 가능 -포인터 타입을 다른것으로 변환 하는 것을 허용하지 않는다 

4) const_cast <new_type> (expression) -상수변수의 상수성을 없애는 용도로 사용 -포인터 타입과 참조형에 대해서만 사용 -동일 타입의 포인터와 참조형에 대해서만 사용 -동일 타입 외에 어떤 연관 관계 타입에 대해서도 허용되지 않음


2. 다음에 대해 조사를 하시오.

1) typeid()란? 
typeid는 자료형이나 변수 또는 객체를 받아 const type_info& 형식으로 입력받은 값의 타입을 return해주는 함수이다. 
그리고 값을 받을 때 포인터 타입을 구분한다(포인터 변수일 경우 값 앞에 *를 붙이면 포인터가 가르키는 객체의 타입을 return 하고 그냥 쓰면 포인터로 선언한 타입을 return 한다) 
이는 사용하기에 따라 개발자가 디버깅을 할때 형 변환 체크에 도움이 되며 type에 따라 실행되는 결과가 다른 조건문을 만들 수 도 있다. 
type_info 에는 ==, !=같은 비교 연산자와 before(), name(), raw_name, hash_code()등의 함수가 존재하는데 각각 기본 자료형의 정렬된 순서에 따라 높으면 1 낮으면 0을 반환 return 값을 char로 형변환 압축된 형식의 문자열 반환 타입의 hash code 반환 을 한다. 사용법은 typeid(). 뒤에 붙이면 된다. ex) typeid(/*type*/).name() typeid(/*type*/).before(/*type*/) before 같은 경우는 구조체나 class 에서는 제대로 작동하지 않지만 부모 자식 class를 집어넣는 경우에는 부모 클래스가 항상 상위에 존재한다 
ex) typeid(부모).before(자식) = 1 typeid(자식).before(부모) = 0 

2) sizeof()란? 
sizeof는 자료형이나 변수 또는 객체를 받아 그 크기를 byte단위로 return해 주는 함수이다 
하지만 이는 컴파일러가 지원하는 비트수에 따라 크기가 달라진다. 
배열의 경우에는 배열의 총 크기를 return하므로 만일 배열의 요소 개수를 확인하고 싶을때는 sizeof(배열) / sizeof(배열[0]) 이라는 식을 사용한다. 

3) typedef 란? 
typedef는 새로운 type을 만드는 것이 아닌 기존 type의 별칭을 만드는 것이다. 복잡한 type을 간단하게 만들고 싶거나 가독성을 위해서, 혹은 호환성을 위해서 쓰인다 
변수명으로써는 다 나타내지 못한 반환 값의 목적을 나타내기 위해서나 사용되는 플랫폼의 지원 비트에 따라 달라지는 자료형을 통일한다던지 플랫폼마다 다르게 사용되는 타입의 이름을 정의하는 식으로 사용이된다.

				소감 

박종국: 저번 강의시간에 행변환에 배울 때 너무 처음 보는 것 들을 한꺼번에 너무 많이 배워서 머릿속이 새하얗게 되었었는데 이렇게 팀 과제를 통하면서 단순히 외우는게 아닌 이해를 할 수 있는 좋은 시간이 된것같습니다.
특히 sizeof는 잘 안다고 생각했지만 배열의 요소의 개수를 알기 위해서는 
sizeof(배열) / sizeof(배열[0]) 식으로 사용되는것도 처음 알게 되었고
컴파일러에서 지원하는 비트수에 따라 크기가 달라지는것도 이번 과제를 통해서 처음 알게되었습니다.

이창준: 이번 과제를 조사하면서 동적 캐스팅, 정적 캐스팅에 더 자세히 알게 되었고 upcasting과 downcasting은 알았지만  포인터 마저 다른 형으로 재 캐스팅을 할 수 있다는걸 알게 되었으며 typeid를 통해 형식을 변수마냥 이리저리 사용할 수 있다는 것에 놀랐다.
typedef같은 경우에는 1학년때 잠깐 배웠었지만 복잡한 type을 간단히 줄이는 것 만 알았지  플랫폼마다(혹은 지원하는 컴파일러나 운영체제에 따라) 다른 형식으로 사용이 되는 타입 이름을 정의하는 용도 등으로 사용이 되는지는 이번에 처음 알게 되었다.
